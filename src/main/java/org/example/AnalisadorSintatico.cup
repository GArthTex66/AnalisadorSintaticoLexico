package org.example ;

import java_cup.runtime.*;
import java.util.*;

parser code {:
  private HashMap<String,Object> symT = new HashMap<String,Object>();

  public boolean isDeclared(String id) {
    return symT.containsKey(id);
  }

  public boolean isNumber(Object o) {
    return o instanceof Integer || o instanceof Float;
  }
:}

terminal PALAVRA_RESERVADA_PROGRAM, IDENTIFICADOR, PALAVRA_RESERVADA_DECLARE, PALAVRA_RESERVADA_BEGIN, PALAVRA_RESERVADA_END,
PALAVRA_RESERVADA_INTEGER, PALAVRA_RESERVADA_DECIMAL, PALAVRA_RESERVADA_IF, PALAVRA_RESERVADA_THEN, PALAVRA_RESERVADA_ELSE,
PALAVRA_RESERVADA_DO, PALAVRA_RESERVADA_WHILE, PALAVRA_RESERVADA_FOR, PALAVRA_RESERVADA_TO, PALAVRA_RESERVADA_READ,
PALAVRA_RESERVADA_WRITE, LEFT_PARENTHESIS, RIGHT_PARENTHESIS, LITERAL, OPERADOR_ASSIGN, SEMICOLON, COLON, OPERADOR_EQUAL,
OPERADOR_GREAT, OPERADOR_GREATEQUAL, OPERADOR_LESS, OPERADOR_LESSEQUAL, OPERADOR_DIFFERENT, OPERADOR_ADD, OPERADOR_MINUS,
PALAVRA_RESERVADA_OR, OPERADOR_MULT, OPERADOR_PART, PALAVRA_RESERVADA_MOD, PALAVRA_RESERVADA_AND, OPERADOR_LEFT_SHIFT,
OPERADOR_RIGHT_SHIFT, OPERADOR_UNSIGNED_RIGHT_SHIFT, OPERADOR_UNSIGNED_LEFT_SHIFT, PALAVRA_RESERVADA_NOT,COMMA, INTERROGATION;

terminal Integer CONSTANT;
terminal Float FLOAT_CONSTANT;

non terminal program, body, decl_list, decl, type, stmt_list, stmt, assign_stmt, if_stmt, condition,
do_while_stmt, stmt_suffix, for_stmt, while_stmt, read_stmt, write_stmt, writable, expression, simple_expr, term,
factor_a, factor, relop, addop, mulop, shiftop;

non terminal List<String> ident_list;

start with program;

program ::= PALAVRA_RESERVADA_PROGRAM IDENTIFICADOR body;

body ::= PALAVRA_RESERVADA_DECLARE decl_list PALAVRA_RESERVADA_BEGIN stmt_list PALAVRA_RESERVADA_END;

decl_list ::= decl SEMICOLON | decl_list decl SEMICOLON ;

decl ::= type:type ident_list:id_list
    {:

        for (String id : id_list)
            if (isDeclared(id))
                System.out.println("Erro: Variavel ja declarada");
            else
                if (type.equals("integer"))
                    symT.put(id, new Integer(0));
                else
                    symT.put(id, new Float(0));
    :};

ident_list ::= IDENTIFICADOR:id {: RESULT = new ArrayList<String>() {{add(id.toString());}};:} | IDENTIFICADOR:id COMMA ident_list:id_list
    {:
        List<String> aux = new ArrayList<String>();
        aux.addAll(id_list);
        aux.add(id.toString());
        RESULT = aux;
    :};

type ::= PALAVRA_RESERVADA_INTEGER:int_word{:RESULT = int_word;:} |
PALAVRA_RESERVADA_DECIMAL:float_word{:RESULT = float_word;:};

stmt_list ::= stmt SEMICOLON | stmt_list stmt SEMICOLON ;

stmt ::= assign_stmt | if_stmt | while_stmt | do_while_stmt| for_stmt | read_stmt | write_stmt;

assign_stmt ::= IDENTIFICADOR:id OPERADOR_ASSIGN simple_expr:smpl_ex {:
                    if (!isNumber(smpl_ex))
                        System.out.println("Erro: Expressao nao numerica");
                    else if (smpl_ex instanceof Float){
                        if (symT.get(id.toString()) instanceof Integer)
                            System.out.println("Erro: Atribuicao de decimal a inteiro");
                        else
                            symT.put(id.toString(), (Float)smpl_ex);
                    }
                    else{
                        if (symT.get(id.toString()) instanceof Float)
                            System.out.println("Erro: Atribuicao de inteiro a decimal");
                        else
                            symT.put(id.toString(), (Integer)smpl_ex);
                    }
:};

if_stmt ::= PALAVRA_RESERVADA_IF condition PALAVRA_RESERVADA_THEN stmt_list PALAVRA_RESERVADA_END | PALAVRA_RESERVADA_IF
condition PALAVRA_RESERVADA_THEN stmt_list PALAVRA_RESERVADA_ELSE stmt_list PALAVRA_RESERVADA_END;

condition ::= expression:exp {:if ( exp instanceof Boolean) RESULT = exp;
                                else System.out.println("Erro: Expressao nao booleana");:};

do_while_stmt ::= PALAVRA_RESERVADA_DO stmt_list stmt_suffix;

stmt_suffix ::= PALAVRA_RESERVADA_WHILE condition;

for_stmt ::= PALAVRA_RESERVADA_FOR assign_stmt PALAVRA_RESERVADA_TO condition PALAVRA_RESERVADA_DO stmt_list
PALAVRA_RESERVADA_END;

while_stmt ::= PALAVRA_RESERVADA_WHILE condition PALAVRA_RESERVADA_DO stmt_list PALAVRA_RESERVADA_END;

read_stmt ::= PALAVRA_RESERVADA_READ LEFT_PARENTHESIS IDENTIFICADOR RIGHT_PARENTHESIS;

write_stmt ::= PALAVRA_RESERVADA_WRITE LEFT_PARENTHESIS writable:w RIGHT_PARENTHESIS {:System.out.println(w);:};

writable ::= expression:ex{:RESULT = ex;:} | LITERAL:l{:RESULT = ((String) l).toString().replaceAll("\"","");:};

expression ::= simple_expr:smpl_ex
                {:RESULT = smpl_ex;:}
               |
               simple_expr:smpl_ex_a relop:relop simple_expr:smpl_ex_b
               {:
                    if (relop.equals("="))
                        RESULT = new Boolean(((Integer)smpl_ex_a).intValue() == ((Integer)smpl_ex_b).intValue());
                    else if (relop.equals(">"))
                        RESULT = new Boolean(((Integer)smpl_ex_a).intValue() > ((Integer)smpl_ex_b).intValue());
                    else if (relop.equals(">="))
                        RESULT = new Boolean(((Integer)smpl_ex_a).intValue() >= ((Integer)smpl_ex_b).intValue());
                    else if (relop.equals("<"))
                        RESULT = new Boolean(((Integer)smpl_ex_a).intValue() < ((Integer)smpl_ex_b).intValue());
                    else if (relop.equals("<="))
                        RESULT = new Boolean(((Integer)smpl_ex_a).intValue() <= ((Integer)smpl_ex_b).intValue());
                    else if (relop.equals("<>"))
                        RESULT = new Boolean(((Integer)smpl_ex_a).intValue() != ((Integer)smpl_ex_b).intValue());
               :}
               | LEFT_PARENTHESIS expression:exp RIGHT_PARENTHESIS INTERROGATION simple_expr:smpl_ax_a COLON simple_expr:smpl_ax_b
               {:
                    if (exp instanceof Boolean)
                        RESULT = ((Boolean)exp).booleanValue() ? smpl_ax_a : smpl_ax_b;
                    else
                        System.out.println("Erro: Expressao nao booleana");
               :};

simple_expr ::= term:t
                {:RESULT = t;:}
                |
                simple_expr:smpl_ex addop:addop term:t
                {:
                    if (addop.equals("or")){
                        if (t instanceof Boolean && smpl_ex instanceof Boolean)
                            RESULT = ((Boolean)t).booleanValue() || ((Boolean)smpl_ex).booleanValue();
                        else
                            System.out.println("Erro: Operador logico aplicado a um valor nao booleano");
                    } else if(!isNumber(smpl_ex) || !isNumber(t)){
                            System.out.println("Erro: Operador aritmetico aplicado a um valor nao numerico");
                     } else{
                         if (t instanceof Float){
                            if (addop.equals("+"))
                                RESULT = ((Float)smpl_ex).floatValue() + ((Float)t).floatValue();
                            else if (addop.equals("-"))
                                RESULT = ((Float)smpl_ex).floatValue() - ((Float)t).floatValue();
                         }else {
                            if (addop.equals("+"))
                                RESULT = ((Integer)smpl_ex).intValue() + ((Integer)t).intValue();
                            else if (addop.equals("-"))
                                RESULT = ((Integer)smpl_ex).intValue() - ((Integer)t).intValue();
                         }
                     }
                :};

term ::= factor_a:f_a
             {:RESULT = f_a;:}
             |
             term:t mulop:mulop factor_a:f_a
             {:
                if (mulop.equals("and")){
                    if (t instanceof Boolean && f_a instanceof Boolean)
                        RESULT = ((Boolean)t).booleanValue() && ((Boolean)f_a).booleanValue();
                    else
                        System.out.println("Erro: Operador logico aplicado a um valor nao booleano");
                } else if(!isNumber(t) || !isNumber(f_a)){
                    System.out.println("Erro: Operador aritmetico aplicado a um valor nao numerico");
                } else if (  (mulop.equals("/")) && ((Integer)f_a).intValue() == 0){
                    System.out.println("Erro: Divisao por zero");
                }else if ((t instanceof Float)){
                    if (mulop.equals("*"))
                        RESULT = ((Float)t).floatValue() * ((Float)f_a).floatValue();
                    else if (mulop.equals("/"))
                        RESULT = ((Float)t).floatValue() / ((Float)f_a).floatValue();
                    else if (mulop.equals("%"))
                        RESULT = ((Float)t).floatValue() % ((Float)f_a).floatValue();
                } else {
                    if (mulop.equals("*"))
                        RESULT = ((Integer)t).intValue() * ((Integer)f_a).intValue();
                    else if (mulop.equals("/"))
                        RESULT = ((Integer)t).intValue() / ((Integer)f_a).intValue();
                    else if (mulop.equals("%"))
                        RESULT = ((Integer)t).intValue() % ((Integer)f_a).intValue();
                }
             :};

factor_a ::= factor:f
            {:RESULT = f;:}
             |
             PALAVRA_RESERVADA_NOT factor:f
             {: if (f instanceof Boolean)
                    RESULT = !((Boolean)f).booleanValue();
                else
                    System.out.println("Erro: Operador not aplicado a um valor nao booleano");
             :}
             |
             OPERADOR_MINUS factor:f
             {: if ( f instanceof Integer)
                    RESULT = -((Integer)f).intValue();
                else if (f instanceof Float)
                    RESULT = -((Float)f).floatValue();
                else
                    System.out.println("Erro: Operador unario aplicado a um valor nao numerico");
              :};

factor ::=  IDENTIFICADOR:id
            {:
                if (symT.containsKey(id.toString()))
                    RESULT = symT.get(id.toString());
                else
                    System.out.println("Erro: Variavel nao declarada");
            :}
            |
            CONSTANT:c
            {:RESULT = c;:}
            |
            FLOAT_CONSTANT:fc
            {:RESULT = fc;:}
            |
            LEFT_PARENTHESIS expression:e RIGHT_PARENTHESIS
            {:RESULT = e;:};

relop ::= OPERADOR_EQUAL:op_equal{:RESULT = op_equal;:} | OPERADOR_GREAT:op_greater{:RESULT = op_greater;:} |
    OPERADOR_GREATEQUAL:op_greater_equal{:RESULT = op_greater_equal;:} | OPERADOR_LESS:op_less{:RESULT = op_less;:} |
    OPERADOR_LESSEQUAL:op_less_equal{:RESULT = op_less_equal;:} | OPERADOR_DIFFERENT:op_not_equal{:RESULT = op_not_equal;:};

addop ::= OPERADOR_ADD:op_add{:RESULT = op_add;:} | OPERADOR_MINUS:op_minus{:RESULT = op_minus;:} |
    PALAVRA_RESERVADA_OR:op_or{:RESULT = op_or;:};

mulop ::= OPERADOR_MULT:op_mult{:RESULT = op_mult;:} | OPERADOR_PART:op_div{:RESULT = op_div;:} |
    PALAVRA_RESERVADA_MOD:op_mod{:RESULT = op_mod;:} | PALAVRA_RESERVADA_AND:op_and{:RESULT = op_and;:};

shiftop ::= OPERADOR_LEFT_SHIFT | OPERADOR_RIGHT_SHIFT | OPERADOR_UNSIGNED_RIGHT_SHIFT | OPERADOR_UNSIGNED_LEFT_SHIFT;